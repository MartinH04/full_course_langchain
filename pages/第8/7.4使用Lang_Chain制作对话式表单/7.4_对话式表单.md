## 7.4 对话式表单

这一节，我们一起探索这个由大语言模型驱动的提问和用户回答的程序。它并不是我们常见的 AI 程序，这样的程序并非人类提出问题，AI 进行回答。角色发生了转变，AI 主动提出问题，人类进行回答。

这类程序已经被广泛地应用到各种生活场景中。想象一下，你正在参加一个公司的招聘，面试的过程全由这个程序负责。它会向你提出一系列关于岗位的问题，让你来回答，如同真实的面试官。或者，你每天要通过几百个人好友申请、打招呼、了解需求等，这个程序会自动跟新好友聊天，根据他们的回答来更新信息。还有一种情况是，你正在填写一个报名表，这个程序会根据你之前的回答，逐步引导你完成报名。这些都是具体生活中这类程序的使用案例，可以看出其实用性。

一个典型的这类程序需要完成两个主要任务。首先，我们需要让语言模型只负责提问，而不进行回答，同时限制问题的范围。以招聘程序为例，程序只会提出关于岗位认识的问题，让面试者进行回答。

其次，程序需要根据用户的回答来更新数据库和下一个问题。例如，有个用户回答 "我叫美丽"，程序就能够识别出这个用户的名字是 "美丽"，并将其保存到数据库中。然后，程序会检查是否还有其他信息缺失，比如用户的居住城市或邮箱地址等，如果有缺失的信息，它就会选择相应的问题进行提问，如 "你住在哪里？"。一旦所有需要的信息都收集齐全，程序就会结束这一次的对话。

### 7.4.1 OpenAI 函数的标记链

这里将介绍如何创建一个对话式表单，实现用户以自然对话的方式填写表单信息。

在网页上，我们经常见到表单，用户需要填写详细信息。在网页上处理这些表单非常容易，因为信息可以很容易地解析和处理。但是，如果我们将表单放入一个聊天机器人中，并且希望用户能够以自然对话的方式回答。

我们将使用 OpenAI 函数的标记链来给用户的信息做“标记”。

标记链是使用 OpenAI 函数参数来指定一个标记文档的模式。这有助于我们确保模型输出我们想要的精确标签，以及它们对应的类型。

比如我们正在处理一个大量的文本数据，我们希望分析每一段文本的情绪是积极的还是消极的。在这种情况下，我们就可以使用标记链来实现这个功能。我们需要的不仅仅是模型的输出结果，更重要的是，这些结果必须是我们想要的，比如具有情绪类型的标签。

标记链需要在我们想要给文本标注特定属性的时候使用。例如，我们可能会问：“这条信息的情绪是什么？”在这个例子中，“情绪”就是我们想要标注的特定属性，而标记链就可以帮助我们实现这个目标。

通过这种方式，我们不仅可以标注出文本的情绪，还可以标注出文本的其他属性，如主题，作者的观点，等等。这个过程就好像给文本贴上了一张张的标签，让我们可以更快更准确地理解和分析文本。


### 7.4.2 标记链的使用

安装包和设置密钥：

```bash
pip -q install  openai tiktoken
pip install git+https://github.com/hwchase17/langchain
```
注意，因为标记链需要 langchain 新版本才支持，所以我们安装最新版本的 Langchain。

```python
import os
os.environ["OPENAI_API_KEY"] = ""
```
导入类和方法。

```
from langchain.chat_models import ChatOpenAI
from langchain.chains import LLMChain
from langchain.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from enum import Enum
from langchain.chains.openai_functions import (
    create_tagging_chain,
    create_tagging_chain_pydantic,
)
```

我们创建一个 Pydantic 类，该类用于获取用户的姓名、城市、电子邮件等信息。

``` python
class PersonalDetails(BaseModel):
    # 定义数据的类型
    name: str = Field(
        ...,
        description = "这是用户输入的名字"
    )
    city: str = Field(
        ...,
        description = "这是用户输入的居住城市"
    )
    email: str = Field(
        ...,
        description = "这是用户输入的邮箱地址"
    )
```

我们使用 OpenAI 的聊天模型。

``` python
llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo-0613")
```

我们还创建了一个标记链，用于检查过滤链的响应，并将用户详细信息填写到相应的字段中。


``` python
chain = create_tagging_chain_pydantic(PersonalDetails,llm)
```

然后，我们实例化一个空的用户记录，并创建一个标记链来处理用户输入的对话。

#### 示例运行

我们通过一个示例演示了对话式表单的运行过程。用户需要提供姓名、城市和电子邮件。

``` python
test_str1 = "你好，我是美丽，我住在上海浦东，我的邮箱是： liteli1987@gmail.com"
test_res1 = chain.run(test_str1)
```

用户的对话成功被标记到 Pydantic 数据类：

```
PersonalDetails(name='美丽', city='上海浦东', email='liteli1987@gmail.com')
```

我们还可以做一些测试，查看标记链的工作效果。例如我们并不告诉它，我的名字是什么，用人称代词“我”。

```
test_str2 = "我的邮箱是： liteli1987@gmail.com"
test_res2 = chain.run(test_str2)
test_res2
```

它仍然会记录到邮箱这一项。

```
PersonalDetails(name='', city='', email='liteli1987@gmail.com')
```

我们还可以加入一些干扰信息，比如我告诉他，我的邮箱，顺带告诉他我弟弟的邮箱。

```
test_str3 = "我叫美丽，我弟弟的邮箱是：1106968391@qq.com"
test_res3 = chain.run(test_str3)
test_res3
```
它并不会把我弟弟的邮箱记录到我的信息里。

```
PersonalDetails(name='美丽', city='', email='')
```

### 7.4.3 创建提示模板

还记得我们这个程序需要完成的二大任务吗？第一个任务便是我们需要让语言模型只负责提问，而不进行回答，同时限制问题的范围。我们可以设置提示模板, 运行一个大语言模型链完成这一目标。

```
def ask_for_info(ask_for=["name","city","email"]):
    # 定义一个提示模板
    first_prompt = ChatPromptTemplate.from_template(
        """
        假设你现在是一名前台，你现在需要对用户进行询问他个人的具体信息。
        不要跟用户打招呼！你可以解释你需要什么信息。不要说“你好！”！
        接下来你和用户之间的对话都是你来提问，凡是你说的都是问句。
        你每次随机选择{ask_for}列表中的一个项目，向用户提问。
        比如["name","city"]列表，你可以随机选择一个"name", 你的问题就是“请问你的名字是？”
        """
    )
    info_gathering_chain = LLMChain(llm=llm, prompt=first_prompt)
    chat_chain = info_gathering_chain.run(ask_for=ask_for)
    return chat_chain
```

运行这个函数，我们便可以让大语言模型，只提问不回答。我们初始化一个问题。

```
ask_for_info(ask_for=["name","city","email"])
```
直接运行后，大语言模型发起了第一个提问。

```
'请问你的名字是？'
```


### 7.4.4 数据更新和检查

我们定义一个函数，用于检查数据是否填写完整。

```
def check_what_is_empty(user_personal_details):
    ask_for = []
    # 检查项目是否为空
    for field,value in user_personal_details.dict().items():
        if value in [None, "", 0]: 
            print(f"Field '{field}' 为空" )
            ask_for.append(f'{field}')
    return ask_for
```
我们假设 007 用户, 初始数据都没有填写：

```
user_007_personal_details = PersonalDetails(name="",city="",email="")
```

运行函数，查看哪些数据没有填写：

```
ask_for = check_what_is_empty(user_007_personal_details)
ask_for
```
函数调用后，显示 007 的姓名、城市和邮箱都没有填写。

```
Field 'name' 为空
Field 'city' 为空
Field 'email' 为空
['name', 'city', 'email']
```

我们再来定义一个函数，用于获取用户输入信息并且更新用户的信息。

```
def add_non_empty_details(current_details:PersonalDetails, new_details:PersonalDetails):
    # 这是已经填好的用户信息
    non_empty_details = {k:v for k,v in new_details.dict().items() if v not in [None, "", 0]}
    update_details = current_details.copy(update=non_empty_details)
    return update_details
```    

AI 每次提问，用户回答，这个函数根据这个用户的回答更新内存中的用户信息。

```
res = chain.run("我的名字007") 
user_007_personal_details = add_non_empty_details(user_007_personal_details,res)
user_007_personal_details
```

运行标记链后，更新一条数据。

```
PersonalDetails(name='007', city='', email='')
```

更新后，程序需要知道哪些数据没有填写。

```
ask_for = check_what_is_empty(user_007_personal_details)
ask_for
```

调用检查函数后，我们可以看到。

```
["city","email"]
```

刚刚我们定义函数 “check_what_is_empty” 检查哪几项没填，定义函数 “add_non_empty_details” 更新用户信息。有了这两个函数，结合我们的提示模板，实现机器人发起提问。

```
def decide_ask(ask_for=["name","city","email"]):
    if ask_for:
        ai_res = ask_for_info(ask_for=ask_for)
        print(ai_res)
    else:
        print("全部填写完整")
decide_ask(ask_for)  
```
我们定义一个函数，根据 “check_what_is_empty” 检查的结果，决定是否运行 “ask_for_info” 函数。 “ask_for_info” 函数内实现了调用我们的提示模板，运行 LLMChain 链。

我们假设 999 用户过来做测试。

```
user_999_personal_details = PersonalDetails(name="",city="",email="")
```

启动程序，开始提问。

```
decide_ask(ask_for)
```
AI 开始问 999 用户。

```
请问你的名字是？
```

999 用户回答后，AI 更新了该用户的信息。

```
str999 = "我的名字是999"
user_999_personal_details, ask_for_999 = filter_response(str999,user_999_personal_details)
decide_ask(ask_for_999)
```
检查完邮箱地址仍然为空，AI 继续问“请问您的电子邮件地址是多少？”。
```
Field 'email' 为空
请问您的电子邮件地址是多少？
```
999 用户回答自己的邮箱。

```
str999 = "XX@XX.com"
user_999_personal_details, ask_for_999 = filter_response(str999,user_999_personal_details)
decide_ask(ask_for_999)
```
AI　停止提问。

```
＇全部填写完整＇
```



