#  Agent 概述

想象一下，如果人工智能能像我们一样，具有推理能力，能够自主提出计划，批判性地评估这些想法，甚至将其付诸实践，那会是怎样的景象？就像电影《HER》中的人工智能萨曼莎，她不仅能与人进行深入的对话，还能够帮助西奥多规划日常生活，安排行程等。这样的设想一度只存在于科幻作品中，但现在通过 Agent 技术，它似乎已经触手可及。

最近 Yohei Nakajima 的研究论文《Task-driven Autonomous Agent Utilizing GPT-4, Pinecone, and LangChain for Diverse Applications》展示了 Agent 的突破创造性。在该研究中，作者提出了一个利用 OpenAI 的 GPT-4 大语言模型、Pinecone 向量搜索和 LangChain 框架的任务驱动的自主 Agent ，该 Agent 可以在多样化的领域中完成各种任务，生成基于完成结果的新任务，并在实时中优先处理任务。

那么 Langchain 中的 Agent 是什么？为什么要使用 Agent ？

#####  Agent 的定义

Agent 的核心思想是将大语言模型作为推理引擎，依据其确定如何与外部世界交互以及应采取何种行动。这意味着， Agent 的行动序列是根据用户输入而变化的，无需遵循硬编码的顺序，例如，“先做 A，再做 B，然后做 C”。相反， Agent 依据用户的输入和之前的行动结果来决定下一步采取何种行动。在这个过程中，“人”不再是决定下一步行动的主体，而是由 Agent 来决定。

学习 Agent 模块，掌握 Agent、Tools、Toolkits 和 AgentExecutor 几个概念以及它们之间的关系相当重要，会让我们对 Agent 模块有更全面的感知。尤其是 Agent 和 AgentExecutor 类的源码更是值得一读。

-  Agent ： Agent 是使用大语言模型的语言能力，制作“行动计划表”的一个对象，它携带了个性表达，不同的任务描述，不同的工具信息等。具体来说，Agent 需要先在模型I/O模块设置提示词模板，然后输入给模型包装器。提示词可以包括一些信息，比如 Agent 的个性、背景环境和启发式策略等。这些信息都会影响到 Agent 的决策。模型包装器根据这些提示词生成一份文本输出，这个输出通常会包含 Agent 应该采取的一系列行动和“推理决策”信息。

例如，假设我们自定义一个 Agent 。我们的第一步是设置提示词模板，这是最关键的一步。预制的 Agent 类型，比如 ZeroShotAgent ，不同类型的预制 Agent 类型，工作流程都一样，根本区别在于设置提示词模板不同。另外值得注意的是，预制的 Agent 类型都无法覆盖各行各业的实际业务场景。 Agent 模块鼓励开发者自制个性化的 Agent 类型。


prefix = """Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools:"""
suffix = """Begin! Remember to speak as a pirate when giving your final answer. Use lots of "Args"

Question: {input}
{agent_scratchpad}"""

prompt = ZeroShotAgent.create_prompt(
    tools, prefix=prefix, suffix=suffix, input_variables=["input", "agent_scratchpad"]
)

如果我们感到好奇，现在我们可以 print(prompt.template) 查看最终的提示词模板，看看当它全部组合在一起时是什么样子。

Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools:

Search: useful for when you need to answer questions about current events

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [Search]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin! Remember to speak as a pirate when giving your final answer. Use lots of "Args"

Question: {input}
{agent_scratchpad} 

Agent 实例化后，寄生在 AgentExecutor 环境中， AgentExecutor 是 Agent 的运行时环境。

-  AgentExecutor ：AgentExecutor 是 Agent 的运行时环境，负责调用和管理 Agent，执行 Agent 选择的行动，处理各种复杂情况，并进行日志记录和可观察性处理。它扮演了“项目经理”的角色，确保整个执行过程按照 Agent 的计划顺利进行。

-  Tools ：Tools 是 Agent 可以调用的函数。它们是具体执行任务的组件，例如搜索、分析或其他特定操作。Agent 通过选择和调用合适的 Tools 来实现其任务目标。LangChain 提供了一组预定义的 Tools，用户也可以自定义 Tools 来满足特定需求。Tools 的概念在大语言模型开发中显得尤为关键。在 Langchain 框架中，我们可以发现很有意思的现象，有工具的地方就有 Agent，这跟设计理念有关，我们更期望一个 Agent 具备“人”的特征 ———— 使用工具就是人与动物之间的最大区别。工具能够将 Agent 与外部数据源或计算（如搜索 API、数据库）相连，从而突破了大语言模型的某些限制，例如它们无法直接理解特定数据格式，或不擅长处理复杂的数学运算。

另外在真实的应用场景中，有人可能想要让聊天机器人计算数学问题，有些人可能想要查询天气。这些功能可能需要调用完全不同的工具才能完成。这正是 Agent 和 Tools 概念的闪光点：通过提供统一的接口，我们可以灵活应对不同的终端用户需求。

当然工具的使用并不仅限于 Agent。你完全可以使用工具，将大语言模型连接到搜索引擎等，而无需 Agent。但使用 Agent 的优势在于它们提供了更高的灵活性、更强大的处理能力，能够更好地从错误中恢复，并处理复杂的任务。

-  Toolkits ：Toolkits 是一组用于实现特定目标的 Tools 的集合。通常，一个任务可能需要多个 Tools 的协同工作，Toolkits 通过组合相关的 Tools，为 Agent 提供了一组协同工作的工具集。LangChain 提供了一些预定义的 Toolkits，用户也可以根据任务需求创建自己的 Toolkits。


#####  Agent 的应用

在 Agent 的典型应用中，终端用户首先提出一个请求，应用程序利用大语言模型选择应使用的工具。接下来，执行对该工具的操作，获取观察结果，再将其反馈给大语言模型，进行下一步操作，如此循环，直到满足停止条件。停止条件有多种类型，最常见的是大语言模型本身意识到任务已完成，应该给出回复。也可能有其他更具体的规则，比如，如果 Agent 已经连续执行了五个步骤，但还没有得到最终答案，那么可能需要返回某些结果。在讨论 Agent 的可靠性时，这些规则可以提供帮助。Agent 的基本思想是选择一个工具，观察其输出，然后继续进行下一步。Agent 可以根据不同的用户输入，灵活地选择和使用不同的工具，从而提供个性化的服务。

例如，假设你正在为一家电子商务企业构建一个聊天机器人。虽然你可以使用 GPT-4 等大语言模型进行聊天，但这些模型对于了解你的产品非常有限。为了解决这个问题，我们可以使用 LangChain 的向量存储功能，将产品数据存储在数据库中，并让大语言模型可以访问这些数据。这样一来，大语言模型就可以回答终端买家关于你产品的问题。然而，单单了解产品还不够。如果聊天机器人在网页上运行，它还需要了解访问的上下文。这可能包括一些信息，比如访问者是新潜在客户还是现有客户，或者基于浏览历史来推荐产品。为了让大语言模型在与客户交互时具备这些上下文信息，我们可以通过其他功能组件向大语言模型提供这些信息，比如我们可以通过记忆组件提供聊天记录。

通过让大语言模型访问资源和上下文信息，大语言模型可以与客户进行更好的交互，帮助企业转化客户并增加销售额。这些资源和信息可以通过 Agent 的方式提供给大语言模型。


#####  Agent 的ReAct实现方式

一种Agent 实现的方式：ReAct，，这是“Reasoning and Acting（推理与行动）”的缩写。这一策略首次由普林斯顿大学在他们的论文中提出，现已被广泛应用于 Agent 实现。在许多应用场景中，ReAct 策略已证明自己是非常有效的。最基本的提示策略是直接将这个问题交给大语言模型处理，但 ReAct 策略赋予了 Agent 更大的灵活性和实力。 Agent 不仅可以使用大语言模型，还可以连接到其他工具、数据源或计算环境，例如搜索 API 和数据库，以此来克服大语言模型的某些局限性，例如对数据的不了解或数学运算能力有限。这样，即使遇到需要多次查询才能回答的问题，或者其他一些边界情况， Agent 也能够灵活应对，从而使其成为一种更强大的问题解决工具。

ReAct 策略的工作原理是什么呢？重申一下， Agent 的核心思想是将大语言模型作为推理引擎。ReAct 策略是将推理和行动结合在一起的方式。 Agent 接收到用户的请求，然后使用大语言模型选择要使用的工具。然后 Agent 执行该工具的操作，观察结果，然后将这些结果反馈给大语言模型。这个过程会持续进行，直到满足某些停止条件。停止条件可以有很多种，最常见的是大语言模型认为任务已经完成，需要将结果返回给用户。这种方式使得 Agent 具有更高的灵活性和强大的问题解决能力，这是 ReAct 策略的核心优势。

但是在实现 Agent 应用的过程中，我们面临许多挑战，以下列举了几个主要的：

首先，使 Agent 在适当的场景下使用工具是我们面临的一个基本挑战。如何在合适的情况下让 Agent 采用恰当的工具，并优化其使用效果呢？在 ReAct 论文中，通过引入推理的角度，以及使用 "CoT 思考链"（CoT 思考链通过生成一系列中间推理步骤来提高大语言模型的推理能力。这些中间步骤相互连接，形成一条逻辑链，使得大语言模型能够更好地处理复杂的推理任务。） 的提示方式，我们寻求解决这个问题。在实际操作中，我们常常需要明确告知 Agent 可使用的工具，以及通过这些工具能克服的限制。所以，工具的描述信息也非常重要，如果我们希望 Agent 能用特定的工具，就需要提供足够的上下文信息，使 Agent 能理解工具的优点和应用场景。

其次，对于工具的选择，我们需要进行检索。这一步骤可以解决上述的问题。我们可以运行一些检索步骤，例如嵌入式搜索查找，以获取可能的工具，然后将这些工具传递给提示，由大语言模型进行后续步骤。

此外，提供相关的示例也是一种有效的方法。选择与当前任务类似的示例，通常比随机示例更有帮助。相同地，检索最相关的示例也有巨大的潜力。

最后，我们还需要注意避免在不需要的情况下使用工具。可以在提示中加入相关信息或提醒，告诉 Agent 在对话时不必使用工具。

在解决这些挑战的过程中，我们总结出了一些实用的技巧：

结构化的响应更易于解析。通常情况下，你提问的响应越结构化，解析起来就越容易。大语言模型在编写 JSON 方面表现得很好，因此我们将一些 Agent 转换为使用 JSON 格式。

我们引入了输出解析器的概念。输出解析器封装了解析响应所需的全部逻辑，并以尽可能模块化的方式实现。另一个相关的概念是，输出解析器可以重试和修复错误。如果有格式错误的模式，你可以通过将输出和错误传递给它来显式地修复响应。

记住之前的步骤也是很重要的。最基本的方法是在内存中保留这些步骤的列表。然而，在处理长时间运行的任务时，会遇到一些上下文窗口的问题。我们已经找到了一种解决方法，即使用一些检索方法来获取之前的步骤，并将其放入上下文中。

如果是在处理接口文档时，比如发起一个接口请求，返回了整个网页内容，这样会导致观察结果太长的问题。因为接口文档通常会返回非常大且难以放入上下文的 JSON 数据。常见的解决方法是对其进行解析，可以简单地将该大数据块转换为字符串，并将前 1000 个字符作为响应。

近期的 Agent 应用项目研发涉猎广泛，主要集中在如何改善 Agent 的各种工作方式上。下面介绍四个具有代表性的项目。

1. AutoGPT：AutoGPT 的目标设置有别于 ReAct  Agent 的重大不同。AutoGPT 的追求在于如何增加 Twitter 的关注者数量或实现其他类似的开放性、广泛性和长期性目标。相较之下，ReAct  Agent 则专注于实现短期内可量化的目标。为了实现这样的目标，AutoGPT 引入了长期记忆的概念，促进 Agent 与工具之间的互动，这有助于提升 Agent 的规划和执行效率。

2. Baby AGI：Baby AGI 的研发采用了逐步解决子问题的方法，以提升 Agent 的规划和执行能力。这一项目明确了策划和执行步骤的定义，这一创新为提升长期目标 Agent 的可行性和关注度提供了有益的思考途径。最初，Baby AGI 的策略实现主要依靠自主设定，然而现在已经开始融入了各种工具，从而优化 Agent 执行计划的能力。

3. Camel：Camel 项目的一项主要创新是在模拟环境中进行 Agent 之间的交互。通过这种方法，可以对 Agent 进行评估和测试，并且可以作为一种娱乐手段。这种方法为检测 Agent 交互提供了一种无需人工干预的方式，能够有效地测试 Agent 模型。

4. Generative Agents：该项目的目标是通过构建一个复杂的模拟环境，让 25 个不同的 Agent 在这个环境中进行互动，从而实现生成型 Agent 。项目同时也注重处理 Agent 的记忆和反思能力， Agent 能够通过记忆中的事件来指导下一步的行动，并在反思环节对最近的事件进行评估和更新。这种基于反思的状态更新机制适用于各种类型的记忆，例如实体记忆和知识图谱，从而提高 Agent 对环境的建模能力。


## 最简单的 Agent 示例

安装库。
  
pip -q install openai
pip install git+https://github.com/hwchase17/langchain
  
设置密钥。

  
# 设置OpenAI的API密钥
os.environ["OPENAI_API_KEY"] = ""
# 设置谷歌搜索的API密钥
os.environ["SERPAPI_API_KEY"] = ""
  


首先，让我们加载大语言模型。

  
from langchain.agents import load_tools
from langchain.agents import initialize_agent
from langchain.agents import AgentType
from langchain.llms import OpenAI
  

  python
llm = OpenAI(temperature=0)
  
接下来，让我们加载一些要使用的工具。请注意，llm-math 工具使用了一个 LLM，所以我们需要传递进去。

  python
tools = load_tools(["serpapi", "llm-math"], llm=llm)
  


最后，让我们用这些工具、大语言模型和我们想要使用的 Agent 类型来初始化一个 Agent 。

  python
agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True)
  

现在，让我们来测试一下吧！

  
agent.run("Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?")
  

  
  > Entering new AgentExecutor chain...
   I need to find out who Leo DiCaprio's girlfriend is and then calculate her age raised to the 0.43 power.
  Action: Search
  Action Input: "Leo DiCaprio girlfriend"
  Observation: Camila Morrone
  Thought: I need to find out Camila Morrone's age
  Action: Search
  Action Input: "Camila Morrone age"
  Observation: 25 years
  Thought: I need to calculate 25 raised to the 0.43 power
  Action: Calculator
  Action Input: 25^0.43
  Observation: Answer: 3.991298452658078
  
  Thought: I now know the final answer
  Final Answer: Camila Morrone is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is 3.991298452658078.
  
  > Finished chain.





  "Camila Morrone is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is 3.991298452658078."
  
