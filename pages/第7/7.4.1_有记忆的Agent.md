在本文中，我们将探讨如何为 OpenAI Functions Agent 添加记忆功能。OpenAI Functions Agent 是一个能够调用函数并响应函数输入的强大工具，但在默认配置下，它并不具备记忆之前对话内容的能力。然而，在许多实际应用场景中，我们希望 Agent 能够记住之前的对话内容，从而更好地为用户提供服务。

具体来说，我们将设计一个实验，通过这个实验，我们将测试大语言模型是否能记住之前的对话内容，并在后续的对话中正确使用这些信息。我们将从设计问题的角度和步骤开始，然后深入研究如何为 Agent 添加记忆功能，并测试这个功能是否能够满足我们的预期。

我们设计了一些问题，让我们创建的代理来回答。设计这个问题的目的是为了检测大语言模型是否具备记忆能力，是否可以像人类一样记住之前的对话内容。这在实际应用中极为重要，比如在聊天机器人的场景中，我们希望机器人能记住用户的名字和之前的对话内容，以便在后续的对话中为用户提供更个性化的服务。

设计这个问题的步骤如下：

1. 首先，我们通过调用  agent.run("hi")  启动一次会话。这是一个简单的问候，类似于人类的对话开场白。

2. 然后，我们通过  agent.run("my name is bob")  介绍一个名字。这是在告诉大语言模型，我们的名字是 Bob。这一步的目的是为了看是否大语言模型能记住这个信息。

3. 最后，我们通过  agent.run("whats my name")  询问大语言模型我们的名字。这是一个测试，看大语言模型是否记住了我们之前介绍的名字。

这个设计问题的角度主要是从记忆能力和对话能力出发，通过设计这样的对话流程，我们可以测试大语言模型在一次会话中是否能记住之前的信息，并在后续的对话中正确使用这些信息。

下面是为 OpenAI Functions Agent 添加记忆功能的代码示例：

首先从 langchain 模块中导入所需的各种类和函数。

LLMMathChain：这是一个类，用于创建一个能够进行数学计算的大语言模型（Large Language Model, LLM）链。LLM 链是一个特殊的模型，可以将一系列的工具和大语言模型连接起来，使得模型能够执行更复杂的任务。

OpenAI：这是一个类，用于创建一个 OpenAI 大语言模型。可以使用这个类来实例化一个 OpenAI 模型，并在后续的代码中使用它。

SerpAPIWrapper：这是一个类，用于创建一个 SerpAPI 的包装器。SerpAPI 是一个搜索引擎结果页面（Search Engine Results Page, SERP）的 API，可以使用这个类来实例化一个 SerpAPI 对象，并在后续的代码中使用它来进行搜索操作。

SQLDatabase 和 SQLDatabaseChain：这两个类用于创建和管理 SQL 数据库。SQLDatabase 是一个用于表示 SQL 数据库的类，可以使用它来实例化一个 SQL 数据库对象。SQLDatabaseChain 则是一个特殊的链，可以将 SQL 数据库和大语言模型连接起来，使得模型能够执行更复杂的数据库操作。

initialize_agent 和 Tool：这两个函数用于初始化 Agent 和工具。initialize_agent 函数可以用于创建一个 Agent，Tool 函数则用于创建一个工具。

AgentType：这是一个枚举类，定义了各种不同的 Agent 类型。可以使用这个类来指定要创建的 Agent 的类型。

ChatOpenAI：这是一个类，用于创建一个能够进行聊天的 OpenAI 模型。可以使用这个类来实例化一个聊天模型，并在后续的代码中使用它进行聊天操作。

from langchain import (
    LLMMathChain,
    OpenAI,
    SerpAPIWrapper,
    SQLDatabase,
    SQLDatabaseChain,
)
from langchain.agents import initialize_agent, Tool
from langchain.agents import AgentType
from langchain.chat_models import ChatOpenAI

创建一个工具（Tools）列表，其中每个工具都是一个 Tool 对象。Tool 对象主要包含三个属性：name，func 和 description。

llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo-0613")
search = SerpAPIWrapper()
llm_math_chain = LLMMathChain.from_llm(llm=llm, verbose=True)
db = SQLDatabase.from_uri("sqlite:///../../../../../notebooks/Chinook.db")
db_chain = SQLDatabaseChain.from_llm(llm, db, verbose=True)
tools = [
    Tool(
        name="Search",
        func=search.run,
        description="useful for when you need to answer questions about current events. You should ask targeted questions",
    ),
    Tool(
        name="Calculator",
        func=llm_math_chain.run,
        description="useful for when you need to answer questions about math",
    ),
    Tool(
        name="FooBar-DB",
        func=db_chain.run,
        description="useful for when you need to answer questions about FooBar. Input should be in the form of a question containing full context",
    ),
]

为 Agent 添加记忆功能。在 langchain 的 Agent 框架中，记忆是由 ConversationBufferMemory 对象管理的, 根据的需求可以使用其他类型的记忆组件。

extra_prompt_messages：这是一个列表，用于包含一些额外的提示消息。这些消息将被添加到 Agent 的提示模板中。在这个例子中，添加了一个 MessagesPlaceholder 对象，这个对象表示一个占位符，它的值将在运行时被实际的记忆内容替换。

variable_name：这是 MessagesPlaceholder 对象的参数，它表示占位符的变量名。在这个例子中，变量名为 "memory"，这意味着在提示模板中，{{memory}} 将被替换为实际的记忆内容。

memory：这是一个 ConversationBufferMemory 对象，用于管理 Agent 的记忆。在这个例子中，设置了 memory_key 为 "memory"，这意味着记忆内容将存储在 "memory" 这个键下；并且设置了 return_messages 为 True，这意味着记忆内容将包括返回的消息。

from langchain.prompts import MessagesPlaceholder
from langchain.memory import ConversationBufferMemory

agent_kwargs = {
    "extra_prompt_messages": [MessagesPlaceholder(variable_name="memory")],
}
memory = ConversationBufferMemory(memory_key="memory", return_messages=True)

在这段代码中，使用  initialize_agent  函数创建了一个 Agent 实例，并为它配置了工具、大语言模型、Agent 类型、记忆等属性。

 tools ：这是一个  Tool  对象的列表，每个  Tool  对象都代表一个可以被 Agent 使用的工具。这些工具将被用来执行具体的任务，如搜索、计算等。

 llm ：这是之前创建的大语言模型（LLM，Large Language Model）。Agent 将使用这个模型来生成语言输出，以及决定下一步的行动。

 AgentType.OPENAI_FUNCTIONS ：这是一个枚举值，代表 Agent 的类型。在这个例子中，选择了  OPENAI_FUNCTIONS  类型的 Agent，这种类型的 Agent 是为 OpenAI 函数模型特别设计的。

 verbose=True ：这个参数决定了是否在运行过程中打印详细的日志信息。如果设置为  True ，那么在每次 Agent 进行行动时，都会打印出详细的日志信息，这对于调试和理解 Agent 的行为非常有用。

 agent_kwargs ：这是一个字典，用于传递额外的参数给 Agent 类。在这个例子中，传递了  extra_prompt_messages  参数，这个参数包含了额外的提示消息。

 memory ：这是之前创建的  ConversationBufferMemory  对象，用于管理 Agent 的记忆。这个对象将被用来存储和检索 Agent 的记忆内容。

通过这段代码，成功创建了一个具有记忆功能的 Agent。接下来，就可以使用这个 Agent 来进行对话，Agent 将能记住之前的对话内容，并可以根据这些记忆来做出决策。

agent = initialize_agent(
    tools,
    llm,
    agent=AgentType.OPENAI_FUNCTIONS,
    verbose=True,
    agent_kwargs=agent_kwargs,
    memory=memory,
)

启动一次会话。这是一个简单的问候，类似于人类的对话开场白。

agent.run("hi")

Agent 回答了我们。
    
    
    > Entering new  chain...
    Hello! How can I assist you today?
    
    > Finished chain.





    'Hello! How can I assist you today?'

我们通过  agent.run("my name is bob")  介绍一个名字。这是在告诉大语言模型，我们的名字是 Bob。这一步的目的是为了看是否大语言模型能记住这个信息。

agent.run("my name is bob")
    
    
    > Entering new  chain...
    Nice to meet you, Bob! How can I help you today?
    
    > Finished chain.





    'Nice to meet you, Bob! How can I help you today?'

询问大语言模型我们的名字。这是一个测试，看大语言模型是否记住了我们之前介绍的名字。

agent.run("whats my name")

我们看到大语言模型认识了我们之前介绍的名字：Bob。
    
    
    > Entering new  chain...
    Your name is Bob.
    
    > Finished chain.





    'Your name is Bob.'    