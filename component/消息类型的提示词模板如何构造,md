为了开发者可以在不同的情境创建不同的提示词模板，然后在实际对话中动态地填充这些模板，参照以下代码进行配置提示词模板。先定义一个提示词模板，明确表达助手的功能——即从{input_language}翻译至{output_language}。基于这个定义，我们使用SystemMessagePromptTemplate.from_template方法创建了一个系统消息的提示词模板对象。

template = (
    "You are a helpful assistant that translates {input_language} to {output_language}."
)
system_message_prompt = SystemMessagePromptTemplate.from_template(template)
human_template = "{text}"
human_message_prompt=HumanMessagePromptTemplate.from_template(human_template)

接下来，代码同样为人类输入定义了一个简洁的模板，并进一步利用HumanMessagePromptTemplate.from_template实例化了人类消息的提示词模板对象。
为了方便地组合多个角色的模板消息，如系统、AI和人类等，代码利用了ChatPromptTemplate.from_messages方法。这个方法接收一系列的模板对象，并将它们合成为一个完整的聊天提示词模板。
最后，我们使用format_prompt方法，将具体的参数——如输入语言、输出语言和用户文本——绑定进预定义的模板中。这样，经过格式化的提示词可以反映出助手的功能（从英语翻译至法语）和用户的原始输入（"I love programming."），并将其整合为一个完整的、为语言模型准备的提示词，从而引导模型提供相关的回复。 

chat_prompt = ChatPromptTemplate.from_messages(
    [system_message_prompt, human_message_prompt]
)

# get a chat completion from the formatted messages
chat(
    chat_prompt.format_prompt(
        input_language="English", output_language="French", text="I love programming."
    ).to_messages()
)
  这将返回如下输出：
  
AIMessage(content='Sure, here is the translation of "I love programming" in French: J\'aime programmer.', additional_kwargs={}, example=False)
